\documentclass[xcolor={dvipsnames,table}]{beamer}
\mode<presentation>{\usetheme{Warsaw}\usecolortheme{crane}}
\usepackage{centernot}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{tikz}
\usetikzlibrary{shadows}

\usefonttheme{serif}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[babel=true]{microtype}

\title{UNIX Weapons School---Computer Architecture}
\date{}
\author{Nick Black for the\\
Georgia Institute of Technology
}

\begin{document}

\begin{frame}
\titlepage
\begin{center}
\includegraphics[scale=0.33]{images/uws.png}\\
\vspace{.1in}
\tiny{copyright \copyright\ 2013}\\
\includegraphics[scale=.25]{images/cc-logo.pdf}
\includegraphics[scale=.25]{images/cc-new.pdf}
\includegraphics[scale=.25]{images/cc-share.pdf}\\
\tiny{creative commons 3.0 share-alike attribution license}
\end{center}
\end{frame}

\begin{frame}{Recommended Reading}
\small
\begin{itemize}
\item Andi Kleen. ``Linux multi-core scalability.'' Linux Kongress 2009.
\item Ulrich Drepper. ``What Every Programmer Needs to Know About Memory.'' In 8 parts. Linux Weekly News (2007).
\item Paul McKenney. ``Transactional Memory Everywhere.''\\
http://paulmck.livejournal.com (2012).
\item John Shen and Mikko Lipasti. \textit{Modern Processor Design} (2004).
\item \textit{Intel 64 and IA-32 Architectures Optimization Manual}. Intel.
\item Agner Fog. \textit{The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers.}
Regularly updated. http://www.agner.org.
\end{itemize}
\end{frame}

\begin{frame}{Abstraction}
\begin{itemize}
\item ``The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.''\\
\hfill--Edsger Dijkstra
\vfill
\item ``First you learn the value of abstraction. Then you learn the cost of abstraction. Then you're ready to engineer.''\\
\hfill--Kent Beck
\vfill
\item We will draw the line at the electric level.
\end{itemize}
\end{frame}

\begin{frame}{The purpose of a systems programmer}
\textbf{Given system $S$, and problem $P$,\\
we will implement $P$,\\
using the resources of $S$,\\
subject to some constraint.}\\
\vspace{.25in}
That constraint is typically to minimize either:
\begin{itemize}
\vspace{.05in}
\item time to completion,
\vspace{.05in}
\item power to completion, or
\vspace{.05in}
\item $\frac{\text{time to completion}}{\text{utilization}}$
(subject to some minimum utilization).
\end{itemize}
\vspace{.25in}
Proving that these constraints have been met is clearly
dependent upon the details of both $P$ and $S$.
\end{frame}

\begin{frame}{Complementary metal-oxide semiconductors I}
Draw \textit{greatest} power only when changing state\ldots
\begin{equation}
P_{dynamic} = \alpha C_LV_{DD}^{2}f \nonumber
\end{equation}
\begin{description}
\item[$P$] Dynamic power ($W = J/s = \frac{m^{2}\cdot kg}{s^{3}}$)
\item[$C_L$] Load capacitances ($F = \frac{A^{2}\cdot s^{4}}{m^{2}\cdot kg}$)
\item[$\alpha$] Activity factor
\item[$V_{DD}$] Supply voltage ($V = \frac{m^{2}\cdot kg}{A\cdot s^{3}}$)
\item[$f$] Frequency ($1/s$)
\end{description}
\end{frame}

\begin{frame}{Complementary metal-oxide semiconductors II}
\ldots but always consume \textit{some} power:
\begin{equation}
P_{static} = I_{static}\cdot V_{DD} \nonumber
\end{equation}
\begin{description}
\item[$P$] Static power ($W = V\cdot A$)
\item[$I_{static}$] Static current ($I_{subth} + I_{tunnel} + I_{leakage}, A$)
\item[$V_{DD}$] Supply voltage ($V$)
\end{description}
\vfill
Implication: power draw is largely independent of state.
\end{frame}

\begin{frame}{Instructions}
A system starts in some initial state, and while undisturbed, evolves
in discrete time according to some closed function on that state.\\
\vspace{.25in}
Each time step is a \textit{cycle}. 1GHz = 1ns cycle.\\
\vspace{.25in}
``Running a program'' is the act of denoting one or more words of this state
as ``instructions'', causing those words to drive control flow.
\vspace{.25in}
\begin{itemize}
\item Static instructions: Instructions in a sequence
\item Dynamic instructions: Instructions \textit{executed} in a sequence
\item[IPC] Instructions per cycle
\item[CPI] Cycles per instruction
\end{itemize}
\end{frame}

\begin{frame}{Special registers}
\begin{itemize}
\item Often read-only, often require special instructions
\item \textbf{FIXME}
\end{itemize}
\end{frame}

\begin{frame}{Register file (indexed access)}
\begin{itemize}
\item Architectural registers are exposed as PRAM or a stack
\item SRAM cells + read/write lines + decoder tree + sense amps
\item One internal bit line per bit of read port
\item Two internal bit lines per bit of write port
\item One word line per entry
\item Transistor area grows linearly with number of ports
\item Wire pitch area grows with square of number of ports
\end{itemize}
\end{frame}

\begin{frame}{Registers}
\begin{itemize}
\item Read ports pace superscalability
\item Write ports pace instruction retire
\item Register width paces bit parallelism
\item Architectural registers pace memory accesses
\item Physical registers pace OOO hiding of antidependency
% particularly useful for EFLAGS!
\end{itemize}
\end{frame}

\end{document}
